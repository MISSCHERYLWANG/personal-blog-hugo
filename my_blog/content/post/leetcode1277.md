---
title: "1277. Count Square Submatrices with All Ones-数出所有的全1方阵"
date: 2020-06-19T17:41:18+08:00
draft: false
tags: ["LeetCode", "动规"]
categories: ["LeetCode", "动态规划"]

autoCollapseToc: true
---

## 问题描述
>Given a `m * n` matrix of ones and zeros, return how many **square** submatrices have all ones.
>
>>**Example:**
>>
>>**Input:** matrix =
    [
    [0,1,1,1],
    [1,1,1,1],
    [0,1,1,1]
    ]
>>
>>**Output:** 15

从上面的栗子可以看出方形子矩阵边为1的有10个，边为2的有4个，边为3的有1个，所以一共有15个方形子矩阵。

## 题目分析

针对这道题目，最初的想法为动态规划，用一个二维数组，`dp[i][j]`代表`i`行`j`列的矩阵（用matrix[i,j]表示）中方形子矩阵的个数。寻找动规公式，当遍历的元素为1时，可以发现`dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+matrix[i,j]中以(i,j)为起点边为1、2、3直到矩阵边界所形成的元素全为1的方形矩阵`，因为`dp[i-1][j-1]`被多加了一次，可以理解。其中最后加的这一项是指`i`行`j`列的子矩阵以`(i,j)`这个元素向左上扩展，这样得到的满足要求的方阵个数。

这样，又想这样是不是太麻烦了，因为每次都要判断向左上角扩展有几个全1方阵，那直接用`dp[i][j]`来存储这个信息，然后结果就是所有的元素之和。为了减小空间复杂度，直接用原矩阵来存储这个值。结合逻辑和实例可得，动规方程为
$$
dp[i][j]= 
\begin{cases}
min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1, & \text{if $matrix[i][j] == 1$} \\\\[2ex]
0, & \text{if $matrix[i][j] == 0$}
\end{cases}
$$

利用栗子来看一下动规数组（下表所示），$ 1\times6+2\times3+3=15$。首先，明确`dp[i][j]`表示从第i行第j列这个元素向左上扩展，能够形成的全一方阵的个数，那么`dp[i][0]`和`dp[0][j]`和原数组对应位置元素是一样的。拿(1,1)位置举例，`matrix[1][1]`为1，那么意味着除它本身为一个边为1的方阵之外，它有更多方阵的可能，然后它周围的`dp[1][0],dp[0][1]和dp[0][0]`中**最短**的那个“板”就表示它能够形成几个方阵。其余元素为1的同理。那么当该位置为0时就表示不能向左上扩展形成方阵，即为0。

|   |  0  |  1  |  2  |  3  |
|:-:| :-: | :-: | :-: | :-: |
| 0 |  0  |  1  |  1  |  1  |
| 1 |  1  |  1  |  2  |  2  |
| 2 |  0  |  1  |  2  |  3  |


## 复杂度分析

时间复杂度：$O(mn)$。需要遍历整个数组。

空间复杂度：$O(1)$。只需一个存储结果的变量，可利用matrix来存储dp数据。